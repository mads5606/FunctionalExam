"use strict";
exports.__esModule = true;
exports.schedulerFor = exports.scheduler = void 0;
var tslib_1 = require("tslib");
var symbols_1 = require("../symbols");
var Arbitrary_1 = require("./definition/Arbitrary");
var Shrinkable_1 = require("./definition/Shrinkable");
var stringify_1 = require("../../utils/stringify");
var TextEscaper_1 = require("./helpers/TextEscaper");
var SchedulerImplem = (function () {
    function SchedulerImplem(act, taskSelector) {
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
    }
    SchedulerImplem.buildLog = function (reportItem) {
        return "[task${" + reportItem.taskId + "}] " + (reportItem.label.length !== 0 ? reportItem.schedulingType + "::" + reportItem.label : reportItem.schedulingType) + " " + reportItem.status + (reportItem.outputValue !== undefined ? " with value " + TextEscaper_1.escapeForTemplateString(reportItem.outputValue) : '');
    };
    SchedulerImplem.prototype.log = function (schedulingType, taskId, label, metadata, status, data) {
        this.triggeredTasks.push({
            status: status,
            schedulingType: schedulingType,
            taskId: taskId,
            label: label,
            metadata: metadata,
            outputValue: data !== undefined ? stringify_1.stringify(data) : undefined
        });
    };
    SchedulerImplem.prototype.scheduleInternal = function (schedulingType, label, task, metadata, thenTaskToBeAwaited) {
        var _this = this;
        var trigger = null;
        var taskId = ++this.lastTaskId;
        var scheduledPromise = new Promise(function (resolve, reject) {
            trigger = function () {
                (thenTaskToBeAwaited ? task.then(function () { return thenTaskToBeAwaited(); }) : task).then(function (data) {
                    _this.log(schedulingType, taskId, label, metadata, 'resolved', data);
                    return resolve(data);
                }, function (err) {
                    _this.log(schedulingType, taskId, label, metadata, 'rejected', err);
                    return reject(err);
                });
            };
        });
        this.scheduledTasks.push({
            original: task,
            scheduled: scheduledPromise,
            trigger: trigger,
            schedulingType: schedulingType,
            taskId: taskId,
            label: label,
            metadata: metadata
        });
        return scheduledPromise;
    };
    SchedulerImplem.prototype.schedule = function (task, label, metadata) {
        return this.scheduleInternal('promise', label || '', task, metadata);
    };
    SchedulerImplem.prototype.scheduleFunction = function (asyncFunction) {
        var _this = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.scheduleInternal('function', asyncFunction.name + "(" + args.map(stringify_1.stringify).join(',') + ")", asyncFunction.apply(void 0, tslib_1.__spread(args)), undefined);
        };
    };
    SchedulerImplem.prototype.scheduleSequence = function (sequenceBuilders) {
        var _this = this;
        var status = { done: false, faulty: false };
        var dummyResolvedPromise = { then: function (f) { return f(); } };
        var resolveSequenceTask = function () { };
        var sequenceTask = new Promise(function (resolve) { return (resolveSequenceTask = resolve); });
        sequenceBuilders
            .reduce(function (previouslyScheduled, item) {
            var _a = tslib_1.__read(typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata], 3), builder = _a[0], label = _a[1], metadata = _a[2];
            return previouslyScheduled.then(function () {
                var scheduled = _this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, function () { return builder(); });
                scheduled["catch"](function () {
                    status.faulty = true;
                    resolveSequenceTask();
                });
                return scheduled;
            });
        }, dummyResolvedPromise)
            .then(function () {
            status.done = true;
            resolveSequenceTask();
        }, function () {
        });
        return Object.assign(status, {
            task: Promise.resolve(sequenceTask).then(function () {
                return { done: status.done, faulty: status.faulty };
            })
        });
    };
    SchedulerImplem.prototype.count = function () {
        return this.scheduledTasks.length;
    };
    SchedulerImplem.prototype.internalWaitOne = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var taskIndex, _a, scheduledTask, _err_1;
            return tslib_1.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.scheduledTasks.length === 0) {
                            throw new Error('No task scheduled');
                        }
                        taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
                        _a = tslib_1.__read(this.scheduledTasks.splice(taskIndex, 1), 1), scheduledTask = _a[0];
                        scheduledTask.trigger();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4, scheduledTask.scheduled];
                    case 2:
                        _b.sent();
                        return [3, 4];
                    case 3:
                        _err_1 = _b.sent();
                        return [3, 4];
                    case 4: return [2];
                }
            });
        });
    };
    SchedulerImplem.prototype.waitOne = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.act(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, this.internalWaitOne()];
                                case 1: return [2, _a.sent()];
                            }
                        }); }); })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    SchedulerImplem.prototype.waitAll = function () {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.scheduledTasks.length > 0)) return [3, 2];
                        return [4, this.waitOne()];
                    case 1:
                        _a.sent();
                        return [3, 0];
                    case 2: return [2];
                }
            });
        });
    };
    SchedulerImplem.prototype.report = function () {
        return tslib_1.__spread(this.triggeredTasks, this.scheduledTasks.map(function (t) { return ({
            status: 'pending',
            schedulingType: t.schedulingType,
            taskId: t.taskId,
            label: t.label,
            metadata: t.metadata
        }); }));
    };
    SchedulerImplem.prototype.toString = function () {
        return ('schedulerFor()`\n' +
            this.report()
                .map(SchedulerImplem.buildLog)
                .map(function (log) { return "-> " + log; })
                .join('\n') +
            '`');
    };
    SchedulerImplem.prototype[symbols_1.cloneMethod] = function () {
        return new SchedulerImplem(this.act, this.sourceTaskSelector);
    };
    return SchedulerImplem;
}());
var SchedulerArbitrary = (function (_super) {
    tslib_1.__extends(SchedulerArbitrary, _super);
    function SchedulerArbitrary(act) {
        var _this = _super.call(this) || this;
        _this.act = act;
        return _this;
    }
    SchedulerArbitrary.prototype.generate = function (mrng) {
        var buildNextTaskIndex = function (r) {
            return {
                clone: function () { return buildNextTaskIndex(r.clone()); },
                nextTaskIndex: function (scheduledTasks) {
                    return r.nextInt(0, scheduledTasks.length - 1);
                }
            };
        };
        return new Shrinkable_1.Shrinkable(new SchedulerImplem(this.act, buildNextTaskIndex(mrng.clone())));
    };
    return SchedulerArbitrary;
}(Arbitrary_1.Arbitrary));
function scheduler(constraints) {
    var _a = (constraints || {}).act, act = _a === void 0 ? function (f) { return f(); } : _a;
    return new SchedulerArbitrary(act);
}
exports.scheduler = scheduler;
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    var _a = (Array.isArray(customOrderingOrConstraints)
        ? constraintsOrUndefined || {}
        : customOrderingOrConstraints || {}).act, act = _a === void 0 ? function (f) { return f(); } : _a;
    var buildSchedulerFor = function (ordering) {
        var buildNextTaskIndex = function () {
            var numTasks = 0;
            return {
                clone: function () { return buildNextTaskIndex(); },
                nextTaskIndex: function (scheduledTasks) {
                    if (ordering.length <= numTasks) {
                        throw new Error("Invalid schedulerFor defined: too many tasks have been scheduled");
                    }
                    var taskIndex = scheduledTasks.findIndex(function (t) { return t.taskId === ordering[numTasks]; });
                    if (taskIndex === -1) {
                        throw new Error("Invalid schedulerFor defined: unable to find next task");
                    }
                    ++numTasks;
                    return taskIndex;
                }
            };
        };
        return new SchedulerImplem(act, buildNextTaskIndex());
    };
    if (Array.isArray(customOrderingOrConstraints)) {
        return buildSchedulerFor(customOrderingOrConstraints);
    }
    else {
        return function (_strs) {
            var ordering = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                ordering[_i - 1] = arguments[_i];
            }
            return buildSchedulerFor(ordering);
        };
    }
}
exports.schedulerFor = schedulerFor;
